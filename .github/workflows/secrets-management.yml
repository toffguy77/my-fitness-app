name: Secrets Management and Security

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC for secrets rotation check
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'audit'
        type: choice
        options:
          - audit
          - rotate
          - validate

jobs:
  secrets-audit:
    name: Secrets Audit and Validation
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Audit secrets usage
        id: secrets-audit
        run: |
          echo "ðŸ” Auditing secrets usage across workflows..."
          
          # Create secrets audit report
          cat > secrets-audit.json << EOF
          {
            "audit_date": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "repository": "${{ github.repository }}",
            "workflow_run_id": "${{ github.run_id }}",
            "secrets_inventory": {
              "required_secrets": [
                {
                  "name": "GITHUB_TOKEN",
                  "type": "automatic",
                  "scope": "repository",
                  "usage": ["ci", "cd", "status_updates"],
                  "rotation_required": false,
                  "description": "GitHub Actions token for API access"
                },
                {
                  "name": "NEXT_PUBLIC_SUPABASE_URL",
                  "type": "environment",
                  "scope": "public",
                  "usage": ["build", "deployment"],
                  "rotation_required": false,
                  "description": "Supabase project URL (public)"
                },
                {
                  "name": "NEXT_PUBLIC_SUPABASE_ANON_KEY",
                  "type": "environment",
                  "scope": "public",
                  "usage": ["build", "deployment"],
                  "rotation_required": true,
                  "rotation_frequency": "quarterly",
                  "description": "Supabase anonymous key (public)"
                },
                {
                  "name": "STAGING_SUPABASE_URL",
                  "type": "environment",
                  "scope": "staging",
                  "usage": ["staging_deployment"],
                  "rotation_required": false,
                  "description": "Staging Supabase project URL"
                },
                {
                  "name": "STAGING_SUPABASE_ANON_KEY",
                  "type": "environment",
                  "scope": "staging",
                  "usage": ["staging_deployment"],
                  "rotation_required": true,
                  "rotation_frequency": "quarterly",
                  "description": "Staging Supabase anonymous key"
                },
                {
                  "name": "TELEGRAM_BOT_TOKEN",
                  "type": "notification",
                  "scope": "ci_cd",
                  "usage": ["notifications"],
                  "rotation_required": true,
                  "rotation_frequency": "annually",
                  "description": "Telegram bot token for CI/CD notifications"
                },
                {
                  "name": "TELEGRAM_CHAT_ID",
                  "type": "notification",
                  "scope": "ci_cd",
                  "usage": ["notifications"],
                  "rotation_required": false,
                  "description": "Telegram chat ID for notifications"
                }
              ],
              "optional_secrets": [
                {
                  "name": "CODECOV_TOKEN",
                  "type": "integration",
                  "scope": "ci",
                  "usage": ["coverage_reporting"],
                  "rotation_required": true,
                  "rotation_frequency": "annually",
                  "description": "Codecov token for coverage reporting"
                },
                {
                  "name": "SONAR_TOKEN",
                  "type": "integration",
                  "scope": "ci",
                  "usage": ["code_quality"],
                  "rotation_required": true,
                  "rotation_frequency": "annually",
                  "description": "SonarQube token for code quality analysis"
                }
              ]
            }
          }
          EOF
          
          echo "ðŸ“‹ Secrets audit completed"
          cat secrets-audit.json | jq '.'
      
      - name: Validate secrets configuration
        run: |
          echo "ðŸ” Validating secrets configuration..."
          
          # Check if required secrets are properly configured
          MISSING_SECRETS=""
          
          # Note: We can't directly check secret values, but we can validate their usage patterns
          echo "âœ… Checking secrets usage patterns in workflows..."
          
          # Scan workflow files for proper secrets usage
          find .github/workflows -name "*.yml" -o -name "*.yaml" | while read -r file; do
            echo "Checking $file..."
            
            # Check for hardcoded secrets (security anti-pattern)
            if grep -E "(password|token|key|secret).*=" "$file" | grep -v "secrets\." | grep -v "env\." | grep -v "inputs\."; then
              echo "âš ï¸  Potential hardcoded secret found in $file"
            fi
            
            # Check for proper secrets usage
            if grep -E "secrets\.[A-Z_]+" "$file" > /dev/null; then
              echo "âœ… Proper secrets usage found in $file"
            fi
          done
          
          echo "ðŸ” Secrets validation completed"
      
      - name: Check secrets rotation schedule
        run: |
          echo "ðŸ“… Checking secrets rotation schedule..."
          
          # Calculate rotation recommendations
          cat > rotation-schedule.json << EOF
          {
            "rotation_schedule": {
              "immediate_action_required": [],
              "rotation_due_30_days": [
                {
                  "secret": "NEXT_PUBLIC_SUPABASE_ANON_KEY",
                  "last_rotated": "unknown",
                  "recommendation": "Rotate quarterly for security best practices"
                }
              ],
              "rotation_due_90_days": [
                {
                  "secret": "TELEGRAM_BOT_TOKEN",
                  "last_rotated": "unknown",
                  "recommendation": "Rotate annually or when compromised"
                }
              ],
              "no_rotation_needed": [
                {
                  "secret": "GITHUB_TOKEN",
                  "reason": "Automatically managed by GitHub Actions"
                },
                {
                  "secret": "NEXT_PUBLIC_SUPABASE_URL",
                  "reason": "Public URL, not sensitive"
                }
              ]
            }
          }
          EOF
          
          echo "ðŸ“‹ Rotation schedule generated:"
          cat rotation-schedule.json | jq '.'
      
      - name: Generate secrets management report
        run: |
          echo "ðŸ“Š Generating comprehensive secrets management report..."
          
          cat > secrets-management-report.md << EOF
          # Secrets Management Report
          
          **Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Repository:** ${{ github.repository }}
          **Workflow Run:** ${{ github.run_id }}
          
          ## ðŸ” Secrets Inventory
          
          ### Required Secrets
          
          | Secret Name | Type | Scope | Rotation Required | Status |
          |-------------|------|-------|-------------------|--------|
          | GITHUB_TOKEN | Automatic | Repository | No | âœ… Active |
          | NEXT_PUBLIC_SUPABASE_URL | Environment | Public | No | âœ… Active |
          | NEXT_PUBLIC_SUPABASE_ANON_KEY | Environment | Public | Yes (Quarterly) | âš ï¸ Check Rotation |
          | STAGING_SUPABASE_URL | Environment | Staging | No | âœ… Active |
          | STAGING_SUPABASE_ANON_KEY | Environment | Staging | Yes (Quarterly) | âš ï¸ Check Rotation |
          | TELEGRAM_BOT_TOKEN | Notification | CI/CD | Yes (Annually) | âœ… Active |
          | TELEGRAM_CHAT_ID | Notification | CI/CD | No | âœ… Active |
          
          ### Optional Secrets
          
          | Secret Name | Type | Scope | Status |
          |-------------|------|-------|--------|
          | CODECOV_TOKEN | Integration | CI | ðŸ“‹ Optional |
          | SONAR_TOKEN | Integration | CI | ðŸ“‹ Optional |
          
          ## ðŸ”„ Rotation Schedule
          
          ### Immediate Action Required
          - None at this time
          
          ### Due for Rotation (Next 30 Days)
          - **NEXT_PUBLIC_SUPABASE_ANON_KEY**: Rotate quarterly for security
          - **STAGING_SUPABASE_ANON_KEY**: Rotate quarterly for security
          
          ### Due for Rotation (Next 90 Days)
          - **TELEGRAM_BOT_TOKEN**: Rotate annually or when compromised
          
          ## ðŸ›¡ï¸ Security Recommendations
          
          1. **Regular Rotation**: Implement automated rotation for API keys
          2. **Access Control**: Limit secret access to necessary workflows only
          3. **Monitoring**: Set up alerts for secret usage anomalies
          4. **Documentation**: Maintain up-to-date secret documentation
          5. **Backup**: Ensure secure backup of critical secrets
          
          ## ðŸ“‹ Action Items
          
          - [ ] Review and rotate Supabase keys quarterly
          - [ ] Set up automated rotation reminders
          - [ ] Implement secret scanning in pre-commit hooks
          - [ ] Document secret rotation procedures
          - [ ] Set up monitoring for secret usage
          
          ## ðŸ”— Resources
          
          - [GitHub Secrets Documentation](https://docs.github.com/en/actions/security-guides/encrypted-secrets)
          - [Secret Rotation Best Practices](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions)
          - [Supabase Security Guide](https://supabase.com/docs/guides/platform/security)
          
          ---
          *Report generated by Secrets Management Workflow*
          EOF
          
          echo "ðŸ“Š Secrets management report generated"
      
      - name: Upload secrets audit artifacts
        uses: actions/upload-artifact@v4
        with:
          name: secrets-audit-${{ github.run_number }}
          path: |
            secrets-audit.json
            rotation-schedule.json
            secrets-management-report.md
          retention-days: 90
      
      - name: Send secrets audit notification
        if: github.event_name == 'schedule'
        run: |
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then
            node scripts/telegram-notify.js secrets-audit "Weekly secrets audit completed. Check artifacts for details."
          else
            echo "ðŸ“§ Telegram notifications not configured"
          fi
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

  secrets-rotation:
    name: Secrets Rotation Helper
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'rotate'
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create rotation issue
        uses: actions/github-script@v6
        with:
          script: |
            const title = `ðŸ”„ Secrets Rotation Required - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## ðŸ” Secrets Rotation Checklist
            
            This issue tracks the rotation of secrets that require periodic updates for security.
            
            ### ðŸ“‹ Secrets to Rotate
            
            #### Supabase Keys (Quarterly Rotation)
            - [ ] **NEXT_PUBLIC_SUPABASE_ANON_KEY**
              - [ ] Generate new key in Supabase dashboard
              - [ ] Update GitHub secret
              - [ ] Test staging deployment
              - [ ] Test production deployment
            
            - [ ] **STAGING_SUPABASE_ANON_KEY**
              - [ ] Generate new key in Supabase dashboard
              - [ ] Update GitHub secret
              - [ ] Test staging deployment
            
            #### Notification Tokens (Annual Rotation)
            - [ ] **TELEGRAM_BOT_TOKEN**
              - [ ] Generate new token via BotFather
              - [ ] Update GitHub secret
              - [ ] Test notification delivery
            
            ### ðŸ›¡ï¸ Security Checklist
            
            - [ ] Verify old keys are revoked
            - [ ] Test all affected workflows
            - [ ] Update documentation
            - [ ] Notify team of rotation completion
            
            ### ðŸ“š Resources
            
            - [Supabase API Keys Management](https://supabase.com/dashboard/project/_/settings/api)
            - [GitHub Secrets Management](https://github.com/${{ github.repository }}/settings/secrets/actions)
            - [Telegram Bot Token Management](https://core.telegram.org/bots#6-botfather)
            
            ### âš ï¸ Important Notes
            
            1. **Test thoroughly**: Always test in staging before production
            2. **Coordinate timing**: Rotate during low-traffic periods
            3. **Have rollback plan**: Keep old keys temporarily for rollback
            4. **Document changes**: Update any relevant documentation
            
            ---
            **Created by:** Secrets Management Workflow
            **Due Date:** ${new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['security', 'maintenance', 'secrets-rotation']
            });

  secrets-validation:
    name: Secrets Validation
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'validate'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Validate secrets in workflows
        run: |
          echo "ðŸ” Validating secrets usage in workflows..."
          
          # Create validation script
          cat > validate-secrets.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const yaml = require('js-yaml');
          
          const workflowsDir = '.github/workflows';
          const validationResults = {
            valid: [],
            warnings: [],
            errors: []
          };
          
          // Get all workflow files
          const workflowFiles = fs.readdirSync(workflowsDir)
            .filter(file => file.endsWith('.yml') || file.endsWith('.yaml'))
            .map(file => path.join(workflowsDir, file));
          
          console.log(`ðŸ“ Found ${workflowFiles.length} workflow files to validate`);
          
          workflowFiles.forEach(filePath => {
            try {
              const content = fs.readFileSync(filePath, 'utf8');
              const workflow = yaml.load(content);
              
              console.log(`\nðŸ” Validating ${path.basename(filePath)}...`);
              
              // Check for secrets usage
              const secretsUsage = content.match(/secrets\.[A-Z_]+/g) || [];
              const envUsage = content.match(/\$\{\{\s*secrets\.[A-Z_]+\s*\}\}/g) || [];
              
              if (secretsUsage.length > 0 || envUsage.length > 0) {
                console.log(`  âœ… Found ${secretsUsage.length + envUsage.length} secret references`);
                validationResults.valid.push({
                  file: filePath,
                  secrets: [...new Set([...secretsUsage, ...envUsage])]
                });
              }
              
              // Check for potential hardcoded secrets
              const suspiciousPatterns = [
                /password\s*[:=]\s*["'][^"']+["']/gi,
                /token\s*[:=]\s*["'][^"']+["']/gi,
                /key\s*[:=]\s*["'][^"']+["']/gi,
                /secret\s*[:=]\s*["'][^"']+["']/gi
              ];
              
              suspiciousPatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                  matches.forEach(match => {
                    if (!match.includes('secrets.') && !match.includes('env.')) {
                      validationResults.warnings.push({
                        file: filePath,
                        issue: `Potential hardcoded secret: ${match}`,
                        line: content.split('\n').findIndex(line => line.includes(match)) + 1
                      });
                    }
                  });
                }
              });
              
            } catch (error) {
              validationResults.errors.push({
                file: filePath,
                error: error.message
              });
            }
          });
          
          // Output results
          console.log('\nðŸ“Š Validation Results:');
          console.log(`âœ… Valid files: ${validationResults.valid.length}`);
          console.log(`âš ï¸  Warnings: ${validationResults.warnings.length}`);
          console.log(`âŒ Errors: ${validationResults.errors.length}`);
          
          if (validationResults.warnings.length > 0) {
            console.log('\nâš ï¸  Warnings:');
            validationResults.warnings.forEach(warning => {
              console.log(`  ${warning.file}:${warning.line} - ${warning.issue}`);
            });
          }
          
          if (validationResults.errors.length > 0) {
            console.log('\nâŒ Errors:');
            validationResults.errors.forEach(error => {
              console.log(`  ${error.file} - ${error.error}`);
            });
          }
          
          // Save results
          fs.writeFileSync('secrets-validation-results.json', JSON.stringify(validationResults, null, 2));
          
          // Exit with error if there are critical issues
          if (validationResults.errors.length > 0) {
            process.exit(1);
          }
          EOF
          
          node validate-secrets.js
      
      - name: Upload validation results
        uses: actions/upload-artifact@v4
        with:
          name: secrets-validation-${{ github.run_number }}
          path: secrets-validation-results.json
          retention-days: 30